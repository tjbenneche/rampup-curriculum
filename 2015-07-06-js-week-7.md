# Data Manipulation

1. Ajax
2. Iterating through (.each)
3. DOM manipulation (append, insertafter insertbefore)

AJAX stands for Asynchronous JavaScript and XML â€” though the name is somewhat misleading, as most AJAX requests deal with data formats other than XML, like JSON and HTML. At its core, it is used to request data to or from a server without reloading the page (e.g. how Facebook refreshes your newsfeed or Gmail fetches new emails). It does this via the XMLHttpRequest API, which consists of a number of different types of requests (depending on whether or not you are trying to receive or post data). For the purposes of this class, we will focus on two: GET and POST.


Ajax requests are triggered by JavaScript code; your code sends a request to a URL, and when it receives a response, a callback function can be triggered to handle the response. Because the request is asynchronous, the rest of your code continues to execute while the request is being processed, so it's imperative that a callback be used to handle the response.

Unfortunately, different browsers implement the Ajax API differently. Typically this meant that developers would have to account for all the different browsers to ensure that Ajax would work universally. Fortunately, jQuery provides Ajax support that abstracts away painful browser differences. It offers both a full-featured $.ajax() method, and simple convenience methods such as $.get(), $.getScript(), $.getJSON(), $.post(), and $().load().

Most jQuery applications don't in fact use XML, despite the name "Ajax"; instead, they transport data as plain HTML or JSON (JavaScript Object Notation).

In general, Ajax does not work across domains. For instance, a webpage loaded from example1.com is unable to make an Ajax request to example2.com as it would violate the same origin policy. As a work around, JSONP (JSON with Padding) uses "script" tags to load files containing arbitrary JavaScript content and JSON, from another domain. More recently browsers have implemented a technology called Cross-Origin Resource Sharing (CORS), that allows Ajax requests to different domains.

$.each() - for loops


.append, .after, .before

## .ajax()
 
[http://stackoverflow.com/questions/9638853/where-can-i-practice-making-ajax-calls](http://stackoverflow.com/questions/9638853/where-can-i-practice-making-ajax-calls)

### HTTP requests

### GET

### POST

### PUT

.html


## Callbacks

$.get( "myhtmlpage.html", myCallBack );

Executing callbacks with arguments can be tricky.

link Wrong

This code example will not work:

1
$.get( "myhtmlpage.html", myCallBack( param1, param2 ) );
The reason this fails is that the code executes myCallBack( param1, param2 ) immediately and then passes myCallBack()'s return value as the second parameter to $.get(). We actually want to pass the function myCallBack(), not myCallBack( param1, param2 )'s return value (which might or might not be a function). So, how to pass in myCallBack() and include its arguments?

link Right

To defer executing myCallBack() with its parameters, you can use an anonymous function as a wrapper. Note the use of function() {. The anonymous function does exactly one thing: calls myCallBack(), with the values of param1 and param2.

1
2
3
4
5
$.get( "myhtmlpage.html", function() {
 
    myCallBack( param1, param2 );
 
});

## .data()
There's often data about an element you want to store with the element. In plain JavaScript, you might do this by adding a property to the DOM element, but you'd have to deal with memory leaks in some browsers. jQuery offers a straightforward way to store data related to an element, and it manages the memory issues for you.

1
2
3
4
5
// Storing and retrieving data related to an element.
 
$( "#myDiv" ).data( "keyName", { foo: "bar" } );
 
$( "#myDiv" ).data( "keyName" ); // Returns { foo: "bar" }
Any kind of data can be stored on an element. For the purposes of this article, .data() will be used to store references to other elements.

For example, you may want to establish a relationship between a list item and a <div> that's inside of it. This relationship could be established every single time the list item is touched, but a better solution would be to establish the relationship once, then store a pointer to the <div> on the list item using .data():

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
// Storing a relationship between elements using .data()
 
$( "#myList li" ).each(function() {
 
    var li = $( this );
    var div = li.find( "div.content" );
 
    li.data( "contentDiv", div );
 
});
 
// Later, we don't have to find the div again;
// we can just read it from the list item's data
var firstLi = $( "#myList li:first" );
 
firstLi.data( "contentDiv" ).html( "new content" );

## Waiting for DOM to load

This function is slightly better than the original JavaScript one, as it will run as soon as the DOM is ready to manipulated, rather than waiting for all images to load.
$(document).ready(function(){

});

window.onload = function() {
 
    alert( "welcome" );
 
};

## types

Sometimes the typeof operator can be confusing or inconsistent, so instead of using typeof, jQuery offers utility methods to help determine the type of a value.

First of all, you have methods to test if a specific value is of a specific type.

1
2
3
$.isArray([]); // true
$.isFunction(function() {}); // true
$.isNumeric(3.14); // true
Additionally, there is $.type() which checks for the internal class used to create a value. You can see the method as a better alternative for the typeof operator.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
$.type( true ); // "boolean"
$.type( 3 ); // "number"
$.type( "test" ); // "string"
$.type( function() {} ); // "function"
 
$.type( new Boolean() ); // "boolean"
$.type( new Number(3) ); // "number"
$.type( new String('test') ); // "string"
$.type( new Function() ); // "function"
 
$.type( [] ); // "array"
$.type( null ); // "null"
$.type( /test/ ); // "regexp"
$.type( new Date() ); // "date"


## .load()

insert HTML directly into matched element
